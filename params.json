{
  "name": "Jpersis",
  "tagline": "Light weighted persistence framework for Java",
  "body": "# Install\r\n\r\nTo use the latest snapshot jpersis-{version} add the following dependency to your project:\r\n```\r\n<dependency>\r\n   <artifactId>jpersis</artifactId>\r\n   <groupId>com.github.myrealitycoding</groupId>\r\n   <version>{version}</version>\r\n</dependency>\r\n```\r\n\r\n# Getting Started\r\n\r\n## Table of contents\r\n\r\n[I. Why JPersis?](#1-why-jpersis)<br />\r\n[II. Models](#2-models)<br />\r\n[III. Mappers](#3-mappers)<br />\r\n[IV. Example](#4-example)<br />\r\n[V. Drivers](#5-drivers)<br />\r\n[VI. Annotations](#6-annotations)<br />\r\n[VII. Naming](#7-name-converters)<br />\r\n[VIII. References](#8-references)<br />\r\n\r\n<a href=\"#\" name=\"1-why-jpersis\"></a>\r\n# I. Why JPersis?\r\n\r\nWhen using an object oriented language like Java it is time consuming to map data manually from a database to models and vise versa. You have to remember data types, validate input and output and you have to change your code for each use case. JPersis is a light-weighted library which does not require much configuration. You define a datastore, bind a model to it and use so called mappers to interact with the datastore.\r\n\r\n<a href=\"#\" name=\"2-models\"></a>\r\n# II. Models\r\nA model is a simple Java class with attributes. There are some restrictions to fullfill the role:\r\n\r\n* each model has to annotate one and only one field by a ```@PrimaryKey``` annotation\r\n* except ```Date``` no other classes are allowed as field data types\r\n* if a model has a custom field data type, it has to be annotated by ```@Ignored```\r\n* a model needs a public constructor without arguments\r\n\r\nImagine we have a model, called ```User```, it could look something like this:\r\n\r\n```java\r\npublic class User {\r\n\r\n    @PrimaryKey \r\n    private int id;\r\n\r\n    private String name;\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n}\r\n```\r\nYou have created a valid JPersis model, because all requirements are fullfilled.\r\n\r\n<a href=\"#\" name=\"3-mappers\"></a>\r\n# III. Mappers\r\nNow we need to do something with our model. We want to store, read and manipulate data. Each model needs a mapper which is responsible. To implement a mapper you have the following restrictions:\r\n\r\n* each mapper has to be annotated by a ```@Mapper``` annotation which also provides a correct class path to the model\r\n* each mapper has to be an interface\r\n* each method of the mapper needs to be annotated by a supported annotation (See [VI. Annotations](#6-annotations)).\r\n\r\nA sample mapper for our previously created model could look something like this:\r\n\r\n```java\r\n@Mapper(\"my.package.to.the.model.User\")\r\npublic interface UserMapper {\r\n\r\n   @Insert\r\n   boolean insert(User user);\r\n\r\n   @Delete\r\n   boolean delete(User user);\r\n\r\n   @Count\r\n   int count();\r\n\r\n   @Select(condition = \"userName = $1\")\r\n   User findByUserName(String userName);\r\n}\r\n```\r\nThat's it! You have created your first mapper.\r\n<a href=\"#\" name=\"4-example\"></a>\r\n# IV. Example\r\nNow we want some action. We want to use a SQLite datasource. We create a driver first (provided by JPersis) and create an ```JPersis``` object:\r\n```java\r\nDriver driver = new SQLiteDriver(\"database.sql\");\r\nJPersis jpersis = new JPersis(driver);\r\n```\r\nNow our application is ready to use. Let's create a user first:\r\n```java\r\nUser user = new User();\r\nuser.setName(\"Max\");\r\n```\r\nNext we need our mapper. JPersis will provide a mapper for you:\r\n```java\r\nUserMapper mapper = jpersis.map(UserMapper.class);\r\n```\r\nLet's insert our user and check if it worked:\r\n```java\r\nmapper.insert(user); // returns true, seems to be okay!\r\nmapper.count(); // returns 1, there is a user in the database\r\nmapper.findByName(\"Max\"); // Hey Max, how are you doing?\r\n```\r\nNothing more to do. JPersis created a user table internally and inserted the user into it. If we want to avoid custom mappers, we can fall back to default mapping:\r\n\r\n```java\r\nDefaultMapper<User> mapper = jpersis.mapDefault(User.class);\r\nCollection<User> allUsers = mapper.find();\r\n\r\n// We do not want to query always the datastore.\r\n// Instead we are using caching\r\n// Equivalent to:\r\n// CachedDefaultMapper<User> cachedMapper = jpersis.mapDefaultCached(User.class);\r\nCachedDefaultMapper<User> cachedMapper = jpersis.cached(mapper);\r\n```\r\n\r\n<a href=\"#\" name=\"5-drivers\"></a>\r\n# V. Drivers\r\nTo interact with the database, a so called **Driver** is required. A driver maps a general functionality to a technology based functionality (like a general insert command to an MongoDB insert). Furthermore a driver is used by annotation methods.\r\n\r\nBy default, the following drivers will be supported:\r\n* SQLiteDriver\r\n* MySQLDriver\r\n* PostgreSQLDriver\r\n* CassandraDriver (not implemented yet)\r\n* Neo4jDriver (not implemented yet)\r\n* MongoDriver (not implemented yet)\r\n\r\n<a href=\"#\" name=\"6-annotations\"></a>\r\n# VI. Annotations\r\n\r\nThe annotations provided by Jpersis are predefined but it is possible to register custom annotations to Jpersis. Given the following annotation:\r\n```java\r\n@Target(ElementType.METHOD)\r\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface ReturnOne { }\r\n```\r\nAnnotating a method with this annotation should always return for example the value `1`. To do so we need to define a so called `MapperMethod`:\r\n```java\r\npublic class ReturnOneMethod extends AbstractMapperMethod<ReturnOne> {\r\n\r\n  public ReturnOneMethod(ReturnOne one) {\r\n    super(one);\r\n  }\r\n\r\n  @Override\r\n  public void on(Class<?> model, Object[] params, Query query) {\r\n    // we build our query internally to count one element\r\n    // note that this would return 0 if no data is available\r\n    query.limit(1).count();\r\n  }\r\n\r\n  @Override\r\n  protected Class<?>[] supportedReturnTypes(Class<?> model) {\r\n    return new Class<?>[] { Integer.class, int.class };\r\n  }\r\n}\r\n```\r\nFinally we need to register our mapper method:\r\n```java\r\njpersis.register(ReturnOne.class, ReturnOneMethod.class);\r\n```\r\nWe are now able to annotate mappers with the `@ReturnOne` annotation:\r\n```java\r\npublic interface MyMapper {\r\n    /* ... */\r\n    @ReturnOne\r\n    int returnOneOrZero();\r\n    /* ... */\r\n}\r\n```\r\n<a href=\"#\" name=\"7-name-converters\"></a>\r\n# VII. Naming\r\nIt is also possible to customize conversion between Java and database names. To do so, you have to define a ```Naming```. By default, the ```CamelCaseNaming``` is used:\r\n```\r\nmyField -> my_field\r\nmy_field -> myField\r\nMyClass -> my_collection\r\nmy_collection -> MyCollection\r\n```\r\nTo do so, implement your own converter:\r\n```java\r\npublic class CustomNaming implements Naming {\r\n   \r\n   @Override\r\n   public String collectionToJava(String name) {\r\n      return name;\r\n   }\r\n\r\n   @Override\r\n   public String javaToCollection(String name) {\r\n      return name;\r\n   }\r\n\r\n   @Override\r\n   public String fieldToJava(String name) {\r\n      return name;\r\n   }\r\n\r\n   @Override\r\n   public String javaToField(String name) {\r\n      return name;\r\n   }\r\n}\r\n```\r\nAfterwards you can set your converter:\r\n```java\r\njpersis.setNaming(new CustomNaming());\r\n```\r\n# References\r\n<a href=\"#\" name=\"8-references\"></a>\r\nAs of Version 1.1.0 JPersis does support references:\r\n```java\r\npublic class CarPark {\r\n\r\n   @PrimaryKey\r\n   private String id;\r\n\r\n   @Reference(\"de.test.Car\")\r\n   private Collection<Car> cars;\r\n}\r\n```\r\nThis will give you all cars which are referenced to this object. For more information refer to [the actual WIP ticket](https://github.com/MyRealityCoding/jpersis/issues/35).\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}